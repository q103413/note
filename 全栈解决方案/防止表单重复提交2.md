针对 `Vue + Go + Nginx + MySQL + Redis` 这一套经典的技术栈，防止表单重复提交需要构建**多层防御体系**。单一层面的防护往往不足以应对复杂的网络环境或恶意攻击。

以下是从前端到后端的完整解决方案：

---

## 1. 前端层 (Vue)：第一道防线

前端拦截主要是为了提升用户体验，防止由于用户“手抖”或网络延迟导致的无意重复点击。

* **按钮状态控制**：在点击提交后，立即将按钮设为 `disabled` 状态，并展示 `loading` 动画。
* **请求拦截器 (Axios)**：
* 利用 Axios 的 `CancelToken` 或者是 `AbortController`。
* 维护一个正在进行的请求队列，如果同一个 URL 的请求尚未完成，则拦截后续相同的请求。


* **路由守卫**：在页面跳转时清除提交状态，防止后退后再提交。

---

## 2. 接入层 (Nginx)：频率限制

Nginx 可以在请求到达服务器之前，根据 IP 或特定标识进行流量限速。

* **`limit_req` 模块**：
```nginx
# 在 http 模块定义
limit_req_zone $binary_remote_addr zone=mylimit:10m rate=1r/s;

# 在 server/location 模块使用
location /api/submit {
    limit_req zone=mylimit burst=5 nodelay;
}

```


这可以强制同一 IP 在一秒内只能发送有限次数的请求，过滤掉高频的恶意重发。

---

## 3. 业务逻辑层 (Go + Redis)：核心幂等机制

这是最关键的一环，主要有两种常用策略：

### 策略 A：分布式锁 (针对短时间内重复点击)

通过 Redis 设置一个带过期时间的“提交锁”。

1. **生成 Key**：使用 `用户ID + 接口路径 + 参数哈希` (或业务唯一标识)。
2. **执行原子加锁**：使用 Redis 的 `SET key value NX EX 3` (3秒自动过期)。
3. **判断结果**：
* 如果设置成功：执行 Go 业务逻辑。
* 如果设置失败：返回“请勿频繁操作”错误。



### 策略 B：Token 令牌机制 (针对页面刷新重试)

1. **获取 Token**：进入表单页面时，前端先请求 Go 后端获取一个唯一的 `submit_token`，存入 Redis。
2. **提交表单**：提交时 Header 携带该 Token。
3. **校验并删除**：Go 后端利用 Redis 的原子性操作（如 Lua 脚本）执行：`if redis.get(token) == 1 then redis.del(token) return true else return false end`。
4. **结果**：如果删除成功，处理业务；如果 Token 不存在，说明已提交过。

---

## 4. 持久化层 (MySQL)：最终兜底

数据库层通过硬性约束防止产生脏数据。

* **唯一索引 (Unique Index)**：
* 例如：在订单表中，将“外部流水号”或“用户ID+业务防重标识”设为唯一索引。
* Go 执行 `INSERT` 时，如果发生 `Duplicate entry` 错误，说明是重复提交。


* **悲观锁/乐观锁**：针对状态变更（如支付状态更新），使用 `WHERE status = 'pending'` 这种条件更新来确保幂等。

---

## 方案对比与总结

| 防护层级           | 实现方式          | 优点                 | 缺点                 |
| ------------------ | ----------------- | -------------------- | -------------------- |
| **前端 (Vue)**     | 按钮禁用、Loading | 响应快，用户体验好   | 无法防绕过过工具提交 |
| **网关 (Nginx)**   | `limit_req`       | 保护服务器带宽和资源 | 配置较死板，不分业务 |
| **缓存 (Redis)**   | 分布式锁/Token    | **最通用、性能最高** | 需维护 Redis 稳定性  |
| **数据库 (MySQL)** | 唯一约束          | 最可靠，防止数据错乱 | 报错对性能有微量影响 |

### 最佳实践建议

对于一般的业务系统，建议采用 **“前端禁用按钮 + Redis 分布式锁 + MySQL 唯一索引”** 的组合。这种方式既兼顾了用户体验，又能有效应对绝大多数并发重复提交的场景。

**您是否需要我为您提供 Go 语言配合 Redis 实现分布式锁的示例代码？**