在 Vue + Go + Nginx + MySQL + Redis 技术栈中,防止表单重复提交需要前后端配合,建立多层防护机制。以下是完整的解决方案:

## 前端防护(Vue)

**1. 按钮禁用状态**

```javascript
// 组件中
data() {
  return {
    isSubmitting: false,
    formData: {}
  }
},
methods: {
  async submitForm() {
    if (this.isSubmitting) return;
    
    this.isSubmitting = true;
    try {
      await this.$axios.post('/api/submit', this.formData);
      this.$message.success('提交成功');
    } catch (error) {
      this.$message.error('提交失败');
    } finally {
      this.isSubmitting = false;
    }
  }
}
```

**2. 请求去重(Axios拦截器)**

```javascript
// axios配置
const pendingRequests = new Map();

axios.interceptors.request.use(config => {
  const requestKey = `${config.method}_${config.url}_${JSON.stringify(config.data)}`;
  
  if (pendingRequests.has(requestKey)) {
    return Promise.reject(new Error('重复请求'));
  }
  
  pendingRequests.set(requestKey, true);
  config.requestKey = requestKey;
  return config;
});

axios.interceptors.response.use(
  response => {
    pendingRequests.delete(response.config.requestKey);
    return response;
  },
  error => {
    if (error.config) {
      pendingRequests.delete(error.config.requestKey);
    }
    return Promise.reject(error);
  }
);
```

## 后端防护(Go + Redis)

**1. 基于 Token 的防重复提交**

生成表单Token:

```go
// 生成表单页面时返回token
func GetFormToken(c *gin.Context) {
    token := generateToken() // UUID或随机字符串
    userID := getUserID(c)
    
    key := fmt.Sprintf("form_token:%s:%s", userID, token)
    err := redisClient.Set(ctx, key, "1", 5*time.Minute).Err()
    
    c.JSON(200, gin.H{"token": token})
}

// 提交时验证token
func SubmitForm(c *gin.Context) {
    token := c.PostForm("token")
    userID := getUserID(c)
    
    key := fmt.Sprintf("form_token:%s:%s", userID, token)
    
    // 使用DEL命令,删除成功返回1,已删除返回0
    result, err := redisClient.Del(ctx, key).Result()
    if err != nil || result == 0 {
        c.JSON(400, gin.H{"error": "表单已提交或token无效"})
        return
    }
    
    // 处理业务逻辑
    processForm(c)
}
```

**2. 基于唯一请求ID的防重**

```go
func PreventDuplicate() gin.HandlerFunc {
    return func(c *gin.Context) {
        requestID := c.GetHeader("X-Request-ID")
        if requestID == "" {
            c.Next()
            return
        }
        
        userID := getUserID(c)
        key := fmt.Sprintf("request:%s:%s", userID, requestID)
        
        // 使用SetNX,只有key不存在时才设置成功
        success, err := redisClient.SetNX(ctx, key, "1", 10*time.Second).Result()
        if err != nil || !success {
            c.JSON(429, gin.H{"error": "请求处理中,请勿重复提交"})
            c.Abort()
            return
        }
        
        c.Next()
    }
}
```

**3. 分布式锁方案**

```go
func SubmitOrder(c *gin.Context) {
    userID := getUserID(c)
    lockKey := fmt.Sprintf("submit_lock:%s", userID)
    
    // 获取锁,过期时间5秒
    lock := redislock.New(redisClient)
    ctx := context.Background()
    
    lockObtained, err := lock.Obtain(ctx, lockKey, 5*time.Second, nil)
    if err != nil {
        c.JSON(500, gin.H{"error": "系统错误"})
        return
    }
    
    if lockObtained == nil {
        c.JSON(429, gin.H{"error": "操作过于频繁"})
        return
    }
    defer lockObtained.Release(ctx)
    
    // 业务处理
    processOrder(c)
}
```

**4. 数据库唯一索引**

```go
// MySQL表设计
/*
CREATE TABLE orders (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    order_no VARCHAR(64) NOT NULL UNIQUE,  -- 唯一订单号
    amount DECIMAL(10,2),
    status TINYINT,
    created_at TIMESTAMP,
    UNIQUE KEY uk_user_order (user_id, order_no)  -- 联合唯一索引
);
*/

func CreateOrder(order *Order) error {
    result := db.Create(order)
    if result.Error != nil {
        // 检查是否是唯一索引冲突
        if strings.Contains(result.Error.Error(), "Duplicate entry") {
            return errors.New("订单已存在")
        }
        return result.Error
    }
    return nil
}
```

## Nginx 层面防护

```nginx
# 限制请求频率
http {
    limit_req_zone $binary_remote_addr zone=submit_limit:10m rate=1r/s;
    
    server {
        location /api/submit {
            limit_req zone=submit_limit burst=2 nodelay;
            
            # 限制同一IP的并发连接数
            limit_conn_zone $binary_remote_addr zone=addr:10m;
            limit_conn addr 10;
            
            proxy_pass http://backend;
        }
    }
}
```

## 完整流程示例

**前端代码:**

```vue
<template>
  <el-form @submit.prevent="handleSubmit">
    <el-input v-model="form.content" />
    <el-button 
      type="primary" 
      @click="handleSubmit"
      :loading="isSubmitting"
      :disabled="isSubmitting">
      提交
    </el-button>
  </el-form>
</template>

<script>
export default {
  data() {
    return {
      form: { content: '' },
      formToken: '',
      isSubmitting: false
    }
  },
  async created() {
    // 获取表单token
    const res = await this.$axios.get('/api/form-token');
    this.formToken = res.data.token;
  },
  methods: {
    async handleSubmit() {
      if (this.isSubmitting) return;
      
      this.isSubmitting = true;
      try {
        await this.$axios.post('/api/submit', {
          ...this.form,
          token: this.formToken
        }, {
          headers: {
            'X-Request-ID': this.generateRequestId()
          }
        });
        this.$message.success('提交成功');
      } catch (error) {
        this.$message.error(error.response?.data?.error || '提交失败');
      } finally {
        this.isSubmitting = false;
      }
    },
    generateRequestId() {
      return `${Date.now()}_${Math.random().toString(36).substr(2)}`;
    }
  }
}
</script>
```

## 推荐方案组合

根据场景选择合适的组合:

- **一般表单**: 前端按钮禁用 + 后端Token验证
- **支付订单**: 前端防重 + Redis分布式锁 + 数据库唯一索引 + 幂等性设计
- **高并发场景**: Nginx限流 + Redis Token + 分布式锁
- **API接口**: 请求ID去重 + 幂等键设计

多层防护可以有效防止恶意重复提交、网络延迟导致的重复请求等问题。